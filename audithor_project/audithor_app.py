# ==============================================================================
# audithor_app.py - FICHERO PRINCIPAL (REF + BULK-JOBS ANTI-504)
# ==============================================================================
from flask import Flask, render_template, request, jsonify
from flask_cors import CORS
import threading
import webbrowser
from datetime import datetime, timedelta
import pytz
import json
import boto3
import uuid
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

from botocore.exceptions import BotoCoreError, ClientError

# Motor de reglas y colecciones
from rules import RULES_TO_CHECK
from collectors.network_policies import get_network_details_table
from collectors import trailalerts
from collectors import secrets_manager

from collectors import (
    utils, iam, securityhub, exposure, guardduty, waf, cloudtrail,
    cloudwatch, inspector, kms, acm, compute, databases,
    network_policies, connectivity, config_sh, playground, ecr, codepipeline, finops, inventory
)

# ==============================================================================
# CONF. APLICACIÓN FLASK
# ==============================================================================
app = Flask(__name__)
# Si necesitas limitar tamaño de payloads grandes:
app.config["JSON_SORT_KEYS"] = False
app.config["MAX_CONTENT_LENGTH"] = 10 * 1024 * 1024  # 10MB
CORS(
    app,
    resources={r"/api/*": {"origins": "*"}},
    supports_credentials=False,
    allow_headers=["Content-Type", "Authorization"],
    methods=["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]
)

# ==============================================================================
# HELPERS COMUNES
# ==============================================================================
_MADRID = pytz.timezone("Europe/Madrid")

def now_madrid_iso() -> str:
    return datetime.now(_MADRID).strftime("%Y-%m-%d %H:%M:%S %Z")

def _ok(payload: dict, status: int = 200):
    return jsonify(payload), status

def _fail(message: str, status: int = 400, **extra):
    body = {"error": message}
    if extra:
        body.update(extra)
    return jsonify(body), status

def _metadata(session=None) -> dict:
    account_id = "Unknown"
    try:
        if session:
            sts = session.client("sts")
            account_id = sts.get_caller_identity()["Account"]
    except Exception:
        pass
    return {"accountId": account_id, "executionDate": now_madrid_iso()}

def get_boto_session(access_key, secret_key, session_token=None):
    """Creates and returns a Boto3 session from credentials."""
    try:
        if session_token:
            session = boto3.Session(
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key,
                aws_session_token=session_token
            )
        else:
            session = boto3.Session(
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key
            )
        sts_client = session.client('sts')
        sts_client.get_caller_identity()
        return session
    except (BotoCoreError, ClientError) as e:
        print(f"[ERROR] Boto3 session could not be created: {e}")
        return None

# ==============================================================================
# PÁGINAS & HEALTH
# ==============================================================================
@app.route('/')
def dashboard():
    return render_template('dashboard.html')

@app.route('/health')
def health():
    return "ok", 200

# ==============================================================================
# ENDPOINTS API (SINCRONOS, IGUAL QUE TENÍAS)
# ==============================================================================

@app.route('/api/run-iam-audit', methods=['POST'])
def run_iam_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        iam_results = iam.collect_iam_data(session)
        iam_results["users"] = iam.check_critical_permissions(session, iam_results.get("users", []))
        return _ok({"metadata": _metadata(session), "results": iam_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting IAM data: {str(e)}", 500)

@app.route('/api/run-securityhub-audit', methods=['POST'])
def run_securityhub_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        all_regions = utils.get_all_aws_regions(session)
        service_status = securityhub.check_security_hub_status_in_regions(session, all_regions)
        findings_data = securityhub.get_and_filter_security_hub_findings(session, service_status)
        enabled_service_status = [s for s in service_status if s.get('SecurityHubEnabled')]
        return _ok({
            "metadata": _metadata(session),
            "results": {
                "servicesStatus": enabled_service_status,
                "findings": findings_data
            }
        })
    except Exception as e:
        return _fail(f"Unexpected error while collecting Security Hub data: {str(e)}", 500)

@app.route('/api/run-exposure-audit', methods=['POST'])
def run_exposure_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        exposure_results = exposure.collect_exposure_data(session)
        exposure_results["lambda_credentials"] = exposure.scan_lambda_credentials(session)
        return _ok({"metadata": _metadata(session), "results": exposure_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Internet exposure.: {str(e)}", 500)

@app.route('/api/run-guardduty-audit', methods=['POST'])
def run_guardduty_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        guardduty_results = guardduty.collect_guardduty_data(session)
        return _ok({"metadata": _metadata(session), "results": guardduty_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting GuardDuty data: {str(e)}", 500)

@app.route('/api/run-waf-audit', methods=['POST'])
def run_waf_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        waf_results = waf.collect_waf_data(session)
        return _ok({"metadata": _metadata(session), "results": waf_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting WAF data {str(e)}", 500)

@app.route('/api/run-cloudtrail-lookup', methods=['POST'])
def run_cloudtrail_lookup():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)

    data = request.get_json()
    event_name = data.get('event_name')
    start_date_str = data.get('start_date')
    end_date_str = data.get('end_date')
    region = data.get('region')

    if not all([start_date_str, end_date_str, region]):
        return _fail("Missing parameters. Required: 'start_date', 'end_date' and 'region'.", 400)

    try:
        start_time = datetime.strptime(start_date_str, '%d-%m-%Y').replace(tzinfo=pytz.utc)
        end_time = (datetime.strptime(end_date_str, '%d-%m-%Y') + timedelta(days=1, seconds=-1)).replace(tzinfo=pytz.utc)
    except ValueError:
        return _fail("Invalid date format. Use: 'dd-mm-yyyy'.", 400)

    try:
        lookup_results = cloudtrail.lookup_cloudtrail_events(session, region, event_name, start_time, end_time)
        return _ok({"results": lookup_results})
    except Exception as e:
        return _fail(str(e), 500)

@app.route('/api/run-cloudwatch-audit', methods=['POST'])
def run_cloudwatch_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        cloudwatch_results = cloudwatch.collect_cloudwatch_data(session)
        return _ok({"metadata": _metadata(session), "results": cloudwatch_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting CloudWatch/SNS data: {str(e)}", 500)

@app.route('/api/run-inspector-audit', methods=['POST'])
def run_inspector_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        inspector_status = inspector.collect_inspector_status(session)
        inspector_status["findings"] = []  # fast
        return _ok({"metadata": _metadata(session), "results": inspector_status})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Inspector status: {str(e)}", 500)

@app.route('/api/run-acm-audit', methods=['POST'])
def run_acm_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        acm_results = acm.collect_acm_data_web(session)
        return _ok({"metadata": _metadata(session), "results": acm_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting ACM data: {str(e)}", 500)

@app.route('/api/run-compute-audit', methods=['POST'])
def run_compute_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        compute_results = compute.collect_compute_data(session)
        return _ok({"metadata": _metadata(session), "results": compute_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Compute data: {str(e)}", 500)

@app.route('/api/run-databases-audit', methods=['POST'])
def run_databases_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        database_results = databases.collect_database_data(session)
        return _ok({"metadata": _metadata(session), "results": database_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Databases data: {str(e)}", 500)

@app.route('/api/run-network-policies-audit', methods=['POST'])
def run_network_policies_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        network_policies_results = network_policies.collect_network_policies_data(session)
        return _ok({"metadata": _metadata(session), "results": network_policies_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Network Policies data: {str(e)}", 500)

@app.route('/api/run-config-sh-audit', methods=['POST'])
def run_config_sh_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        results = config_sh.collect_config_sh_data(session)
        return _ok({"metadata": _metadata(session), "results": results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Config & Security Hub data: {str(e)}", 500)

@app.route('/api/run-config-sh-status-audit', methods=['POST'])
def run_config_sh_status_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        results = config_sh.collect_config_sh_status_only(session)
        return _ok({"metadata": _metadata(session), "results": results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Config & SH status: {str(e)}", 500)

@app.route('/api/run-network-detail-audit', methods=['POST'])
def handle_network_detail_audit():
    try:
        data = request.get_json()
        if not data:
            return _fail("Invalid request: No JSON payload found.", 400)

        access_key = data.get('access_key')
        secret_key = data.get('secret_key')
        session_token = data.get('session_token')

        session = get_boto_session(access_key, secret_key, session_token)
        if not session:
            return _fail("Failed to create AWS session from provided credentials.", 500)

        resource_id = data.get('resource_id')
        region = data.get('region')
        if not resource_id or not region:
            return _fail("Missing 'resource_id' or 'region' in the request payload.", 400)

        details = get_network_details_table(session, resource_id, region)
        if isinstance(details, str) and details.startswith("Error:"):
            return _fail(details, 400)

        return _ok({"results": {"details_table": details}})
    except Exception as e:
        print(f"[ERROR] en handle_network_detail_audit: {e}")
        return _fail(f"An unexpected server error occurred: {str(e)}", 500)

@app.route('/api/run-connectivity-audit', methods=['POST'])
def run_connectivity_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        connectivity_results = connectivity.collect_connectivity_data(session)
        return _ok({"metadata": _metadata(session), "results": connectivity_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting connectivity data: {str(e)}", 500)

@app.route('/api/run-playground-audit', methods=['POST'])
def run_playground_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        data = request.get_json()
        source_arn = data.get('source_arn')
        target_arn = data.get('target_arn')
        if not source_arn or not target_arn:
            return _fail("Source and destination ARN are required.", 400)

        path_results = playground.analyze_network_path_data(session, source_arn, target_arn)
        return _ok({"metadata": _metadata(session), "results": path_results})
    except ValueError as e:
        return _fail(str(e), 400)
    except Exception as e:
        return _fail(f"Unexpected error while analyzing the network route: {str(e)}", 500)

@app.route('/api/run-kms-audit', methods=['POST'])
def run_kms_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        kms_results = kms.collect_kms_data(session)
        return _ok({"metadata": _metadata(session), "results": kms_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting KMS data: {str(e)}", 500)

@app.route('/api/run-sslscan', methods=['POST'])
def run_sslscan():
    data = request.get_json()
    targets_str = data.get('target') if data else None
    if not targets_str:
        return _fail("No target has been provided.", 400)
    try:
        results = playground.run_sslscan_on_targets(targets_str)
        return _ok({"metadata": {"executionDate": now_madrid_iso()}, "results": results})
    except Exception as e:
        return _fail(f"Unexpected error running sslscan: {str(e)}", 500)

@app.route('/run_executive_summary', methods=['POST'])
def run_executive_summary():
    audit_data = request.json
    if not audit_data:
        return _fail("No audit data provided", 400)

    executive_summary_findings = []
    for rule in RULES_TO_CHECK:
        check_function = rule.get("check_function")
        if callable(check_function):
            violating_resources_raw = check_function(audit_data)
            if violating_resources_raw:
                affected_resources_structured = []
                for resource in violating_resources_raw:
                    if isinstance(resource, dict):
                        affected_resources_structured.append({
                            "display": f"{resource.get('resource')} in {resource.get('region')}",
                            "region": resource.get("region", "Global")
                        })
                    else:
                        affected_resources_structured.append({
                            "display": str(resource),
                            "region": "Global"
                        })
                executive_summary_findings.append({
                    "rule_id": rule.get("rule_id"),
                    "name": rule.get("name"),
                    "severity": rule.get("severity"),
                    "description": rule.get("description"),
                    "remediation": rule.get("remediation"),
                    "status": "🚩 RED FLAG",
                    "affected_resources": affected_resources_structured
                })
    return _ok(executive_summary_findings)

@app.route('/api/run-federation-audit', methods=['POST'])
def run_federation_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        federation_results = iam.collect_federation_data(session)
        return _ok({"metadata": _metadata(session), "results": federation_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting federation data: {str(e)}", 500)

@app.route('/api/run-access-analyzer-audit', methods=['POST'])
def run_access_analyzer_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        analyzer_results = iam.collect_access_analyzer_data(session)
        return _ok({"metadata": _metadata(session), "results": analyzer_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Access Analyzer data: {str(e)}", 500)

@app.route('/api/run-inspector-findings-audit', methods=['POST'])
def run_inspector_findings_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        inspector_findings = inspector.collect_inspector_findings(session)
        return _ok({"metadata": _metadata(session), "results": inspector_findings})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Inspector findings: {str(e)}", 500)

@app.route('/api/get-sso-group-members', methods=['POST'])
def get_sso_group_members_endpoint():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)

    data = request.get_json()
    group_id = data.get('group_id') if data else None
    if not group_id:
        return _fail("Group_id is required.", 400)

    try:
        members = iam.get_sso_group_members(session, group_id)
        return _ok({"members": members})
    except Exception as e:
        return _fail(str(e), 500)

@app.route('/api/run-cloudtrail-audit', methods=['POST'])
def run_cloudtrail_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        cloudtrail_results = cloudtrail.collect_cloudtrail_data(session)
        return _ok({"metadata": _metadata(session), "results": cloudtrail_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting CloudTrail data.: {str(e)}", 500)

@app.route('/api/run-ecr-audit', methods=['POST'])
def run_ecr_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        ecr_results = ecr.collect_ecr_data(session)
        return _ok({"metadata": _metadata(session), "results": ecr_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting ECR data: {str(e)}", 500)

@app.route('/api/check-healthy-status-rules', methods=['POST'])
def check_healthy_status_rules_endpoint():
    audit_data = request.json
    if not audit_data:
        return _fail("No audit data provided", 400)
    try:
        findings = []
        transformed_data = {}
        for service_key, service_data in audit_data.items():
            if service_data and isinstance(service_data, dict) and 'results' in service_data:
                transformed_data[service_key] = service_data['results']
            else:
                transformed_data[service_key] = service_data

        for rule in RULES_TO_CHECK:
            check_function = rule.get("check_function")
            if callable(check_function):
                try:
                    violating_resources = check_function(transformed_data)
                    if violating_resources:
                        affected_resources_list = []
                        for resource in violating_resources:
                            if isinstance(resource, dict) and 'resource' in resource and 'region' in resource:
                                affected_resources_list.append(resource)
                            else:
                                affected_resources_list.append({"resource": str(resource), "region": "Global"})
                        findings.append({
                            "rule_id": rule.get("rule_id"),
                            "section": rule.get("section"),
                            "name": rule.get("name"),
                            "severity": rule.get("severity"),
                            "description": rule.get("description"),
                            "remediation": rule.get("remediation"),
                            "pci_requirement": rule.get("pci_requirement"),
                            "affected_resources": affected_resources_list
                        })
                except Exception as e:
                    print(f"[ERROR] Rule {rule.get('rule_id', 'unknown')} failed: {e}")
                    continue
        return _ok(findings)
    except Exception as e:
        print(f"[ERROR] in check_healthy_status_rules_endpoint: {e}")
        return _fail(f"An error occurred while checking rules: {str(e)}", 500)

@app.route('/api/run-simulate-policy', methods=['POST'])
def run_simulate_policy():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        data = request.get_json()
        username = data.get('username') if data else None
        actions = data.get('actions', []) if data else []
        include_mfa_context = data.get('include_mfa_context', False) if data else False
        if not username:
            return _fail("Username is required.", 400)
        if not actions:
            return _fail("At least one action is required.", 400)

        context_entries = []
        if include_mfa_context:
            context_entries = [{
                'ContextKeyName': 'aws:MultiFactorAuthPresent',
                'ContextKeyValues': ['false'],
                'ContextKeyType': 'boolean'
            }]

        simulation_results = playground.simulate_user_permissions(
            session, username, actions, context_entries
        )
        return _ok({"results": simulation_results})
    except ValueError as e:
        return _fail(str(e), 400)
    except Exception as e:
        return _fail(f"Simulation error: {str(e)}", 500)

@app.route('/api/run-simulate-lambda-policy', methods=['POST'])
def run_simulate_lambda_policy():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        data = request.get_json()
        function_name = data.get('function_name') if data else None
        region = data.get('region') if data else None
        actions = data.get('actions', []) if data else []
        if not function_name or not region:
            return _fail("Function name and region are required.", 400)
        if not actions:
            return _fail("At least one action is required.", 400)

        simulation_results = playground.simulate_lambda_permissions(session, function_name, region, actions)
        return _ok({"results": simulation_results})
    except ValueError as e:
        return _fail(str(e), 400)
    except Exception as e:
        return _fail(f"Simulation error: {str(e)}", 500)

@app.route('/api/run-codepipeline-audit', methods=['POST'])
def run_codepipeline_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        codepipeline_results = codepipeline.collect_codepipeline_data(session)
        return _ok({"metadata": _metadata(session), "results": codepipeline_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting CodePipeline data: {str(e)}", 500)
    
@app.route('/api/run-finops-audit', methods=['POST'])
def run_finops_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        finops_results = finops.collect_finops_data(session)
        return _ok({"metadata": _metadata(session), "results": finops_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting FinOps data: {str(e)}", 500)

@app.route('/api/get-user-assumable-roles', methods=['POST'])
def get_user_assumable_roles_endpoint():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    data = request.get_json()
    username = data.get('username') if data else None
    if not username:
        return _fail("Username is required.", 400)
    try:
        result = iam.get_user_assumable_roles(session, username)
        return _ok(result)
    except Exception as e:
        return _fail("Unexpected error retrieving assumable roles", 500,
                    status="error", username=username, assumable_roles=[], details=str(e))

@app.route('/api/analyze-custom-policy', methods=['POST'])
def analyze_custom_policy_endpoint():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    data = request.get_json()
    policy_name = data.get('policy_name') if data else None
    if not policy_name:
        return _fail("Policy name is required.", 400)
    try:
        result = iam.analyze_custom_policy(session, policy_name)
        return _ok(result)
    except Exception as e:
        return _fail(f"Unexpected error analyzing custom policy: {str(e)}", 500, status="error")

@app.route('/api/update-sigma-rules', methods=['POST'])
def update_sigma_rules():
    try:
        print('Starting Sigma rules update from TrailAlerts repository...')
        result = trailalerts.download_sigma_rules_from_github()
        if result["status"] == "success":
            print(f"Sigma rules updated successfully: {result['message']}")
            metadata = trailalerts.get_rules_metadata()
            return _ok({
                "status": "success",
                "message": result["message"],
                "rules_count": result["rules_count"],
                "last_update": metadata.get("last_update"),
                "metadata": metadata
            })
        else:
            print(f"Error updating Sigma rules: {result['message']}")
            return _fail(result["message"], 500, status="error")
    except Exception as e:
        error_msg = f"Unexpected error updating Sigma rules: {str(e)}"
        print(error_msg)
        return _fail(error_msg, 500, status="error")

@app.route('/api/get-sigma-rules-status', methods=['GET'])
def get_sigma_rules_status():
    try:
        metadata = trailalerts.get_rules_metadata()
        rules = trailalerts.load_parsed_rules()
        return _ok({
            "status": "success",
            "rules_count": len(rules),
            "last_update": metadata.get("last_update"),
            "total_rules_downloaded": metadata.get("total_rules_downloaded", 0),
            "source": metadata.get("source", "Unknown"),
            "rules_available": len(rules) > 0
        })
    except Exception as e:
        return _fail(f"Error getting rules status: {str(e)}", 500,
                    status="error", rules_count=0, rules_available=False)

@app.route('/api/run-trailalerts-analysis', methods=['POST'])
def run_trailalerts_analysis():
    try:
        data = request.get_json()
        if not data:
            return _fail("No data provided", 400)

        start_date = data.get('start_date')
        end_date = data.get('end_date')
        use_dynamic_lookup = data.get('use_dynamic_lookup', False)

        print('Starting TrailAlerts analysis...')
        events_to_analyze = []
        analysis_method = "memory"
        session = None

        if use_dynamic_lookup and start_date and end_date:
            print(f'Using dynamic CloudTrail lookup for date range: {start_date} to {end_date}')
            analysis_method = "dynamic_lookup"
            session, error = utils.get_session(data)
            if error:
                return _fail(f"Invalid credentials for dynamic lookup: {error}", 401)
            try:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            except ValueError:
                return _fail("Invalid date format. Use ISO format with Z suffix.", 400)

            all_regions = utils.get_all_aws_regions(session)
            print(f'Searching CloudTrail events across {len(all_regions)} regions...')
            important_events = [
                "ConsoleLogin", "CreateUser", "DeleteUser", "CreateTrail", "StopLogging",
                "UpdateTrail", "DeleteTrail", "CreateLoginProfile", "DeleteLoginProfile",
                "AuthorizeSecurityGroupIngress", "RevokeSecurityGroupIngress",
                "StartInstances", "StopInstances", "TerminateInstances",
                "DisableKey", "ScheduleKeyDeletion", "CreateRole", "DeleteRole",
                "CreatePolicy", "DeletePolicy", "AttachUserPolicy", "DetachUserPolicy"
            ]
            for region in all_regions:
                try:
                    for event_name in important_events:
                        try:
                            lookup_result = cloudtrail.lookup_cloudtrail_events(
                                session, region, event_name, start_dt, end_dt
                            )
                            events_to_analyze.extend(lookup_result.get("events", []))
                        except Exception as e:
                            print(f"Error looking up {event_name} in {region}: {e}")
                            continue
                except Exception as e:
                    print(f"Error accessing region {region}: {e}")
                    continue

            seen_event_ids = set()
            unique_events = []
            for event in events_to_analyze:
                event_id = event.get("EventId")
                if event_id and event_id not in seen_event_ids:
                    seen_event_ids.add(event_id)
                    unique_events.append(event)
            events_to_analyze = unique_events
            print(f'Found {len(events_to_analyze)} unique events via dynamic lookup')
        else:
            events_to_analyze = data.get('events', [])
            if not events_to_analyze:
                return _fail("No CloudTrail events provided for analysis", 400)

        analysis_result = trailalerts.analyze_events_against_rules(
            events=events_to_analyze,
            start_date=start_date,
            end_date=end_date
        )

        if analysis_result["status"] == "success":
            alerts_count = len(analysis_result["alerts"])
            print(f'TrailAlerts analysis completed. Found {alerts_count} security alerts.')

            account_id = "Unknown"
            try:
                if session:
                    sts_client = session.client("sts")
                    account_id = sts_client.get_caller_identity()["Account"]
            except Exception:
                pass

            return _ok({
                "metadata": {
                    "accountId": account_id,
                    "executionDate": now_madrid_iso(),
                    "analysis_timeframe": analysis_result.get("analysis_timeframe", {}),
                    "events_analyzed": analysis_result["events_analyzed"],
                    "rules_loaded": analysis_result["rules_loaded"],
                    "analysis_method": analysis_method
                },
                "results": {
                    "alerts": analysis_result["alerts"],
                    "summary": {
                        "total_alerts": alerts_count,
                        "critical_alerts": len([a for a in analysis_result["alerts"] if a.get("severity") == "critical"]),
                        "high_alerts": len([a for a in analysis_result["alerts"] if a.get("severity") == "high"]),
                        "medium_alerts": len([a for a in analysis_result["alerts"] if a.get("severity") == "medium"]),
                        "low_alerts": len([a for a in analysis_result["alerts"] if a.get("severity") == "low"])
                    }
                }
            })
        else:
            print(f"TrailAlerts analysis failed: {analysis_result['message']}")
            return _fail(analysis_result["message"], 500,
                         alerts=[], events_analyzed=analysis_result.get("events_analyzed", 0),
                         rules_loaded=analysis_result.get("rules_loaded", 0))
    except Exception as e:
        error_msg = f"Unexpected error in TrailAlerts analysis: {str(e)}"
        print(error_msg)
        return _fail(error_msg, 500)

@app.route('/api/get-trailalerts-rule-details', methods=['POST'])
def get_trailalerts_rule_details():
    try:
        data = request.get_json()
        if not data:
            return _fail("Invalid request: expected JSON payload", 400)
        rule_id = data.get('rule_id')
        if not rule_id:
            return _fail("Rule ID is required", 400)

        rules = trailalerts.load_parsed_rules()
        target_rule = next((r for r in rules if r.get("rule_id") == rule_id), None)
        if not target_rule:
            return _fail(f"Rule with ID '{rule_id}' not found", 404)
        return _ok({"status": "success", "rule": target_rule})
    except Exception as e:
        return _fail(f"Error retrieving rule details: {str(e)}", 500, status="error")

@app.route('/api/run-s3-security-check', methods=['POST'])
def run_s3_security_check():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)

    data = request.get_json()
    bucket_name = data.get('bucket_name') if data else None
    if not bucket_name:
        return _fail("Bucket name is required", 400)
    try:
        s3_client = session.client('s3')
        security_analysis = {
            "bucket_name": bucket_name,
            "issues": [], "warnings": [], "recommendations": [],
            "configuration": {}, "risk_score": 0
        }
        # 1) Public Access Block
        try:
            public_access_block = s3_client.get_public_access_block(Bucket=bucket_name)
            pab_config = public_access_block['PublicAccessBlockConfiguration']
            security_analysis["configuration"]["public_access_block"] = pab_config
            if not pab_config.get('BlockPublicAcls', False):
                security_analysis["issues"].append("Public ACLs are not blocked"); security_analysis["risk_score"] += 20
            if not pab_config.get('IgnorePublicAcls', False):
                security_analysis["issues"].append("Public ACLs are not ignored"); security_analysis["risk_score"] += 20
            if not pab_config.get('BlockPublicPolicy', False):
                security_analysis["issues"].append("Public bucket policies are not blocked"); security_analysis["risk_score"] += 25
            if not pab_config.get('RestrictPublicBuckets', False):
                security_analysis["issues"].append("Public bucket access is not restricted"); security_analysis["risk_score"] += 15
        except ClientError as e:
            if e.response['Error']['Code'] == 'NoSuchPublicAccessBlockConfiguration':
                security_analysis["issues"].append("CRITICAL: No Public Access Block configuration found"); security_analysis["risk_score"] += 30
            else:
                security_analysis["warnings"].append(f"Could not check Public Access Block: {e.response['Error']['Code']}")
        # 2) Bucket policy
        try:
            bucket_policy = s3_client.get_bucket_policy(Bucket=bucket_name)
            policy = json.loads(bucket_policy['Policy'])
            security_analysis["configuration"]["has_bucket_policy"] = True
            for statement in policy.get('Statement', []):
                principal = statement.get('Principal', {})
                if principal == "*" or (isinstance(principal, dict) and principal.get('AWS') == "*"):
                    security_analysis["issues"].append("Bucket policy allows public access via wildcard principal"); security_analysis["risk_score"] += 25
        except ClientError as e:
            if e.response['Error']['Code'] == 'NoSuchBucketPolicy':
                security_analysis["configuration"]["has_bucket_policy"] = False
                security_analysis["warnings"].append("No bucket policy found - relying on ACLs only")
            else:
                security_analysis["warnings"].append(f"Could not check bucket policy: {e.response['Error']['Code']}")
        # 3) Encryption
        try:
            encryption = s3_client.get_bucket_encryption(Bucket=bucket_name)
            security_analysis["configuration"]["encryption"] = encryption['ServerSideEncryptionConfiguration']
            security_analysis["recommendations"].append("Encryption is enabled - good security practice")
        except ClientError as e:
            if e.response['Error']['Code'] == 'ServerSideEncryptionConfigurationNotFoundError':
                security_analysis["issues"].append("No server-side encryption configured"); security_analysis["risk_score"] += 10
                security_analysis["recommendations"].append("Enable server-side encryption (SSE-S3 or SSE-KMS)")
            else:
                security_analysis["warnings"].append(f"Could not check encryption: {e.response['Error']['Code']}")
        # 4) Versioning
        try:
            versioning = s3_client.get_bucket_versioning(Bucket=bucket_name)
            versioning_status = versioning.get('Status', 'Disabled')
            security_analysis["configuration"]["versioning"] = versioning_status
            if versioning_status != 'Enabled':
                security_analysis["warnings"].append("Versioning is not enabled")
                security_analysis["recommendations"].append("Consider enabling versioning for data protection")
            mfa_delete = versioning.get('MfaDelete', 'Disabled')
            security_analysis["configuration"]["mfa_delete"] = mfa_delete
            if mfa_delete != 'Enabled':
                security_analysis["recommendations"].append("Consider enabling MFA Delete for critical buckets")
        except ClientError as e:
            security_analysis["warnings"].append(f"Could not check versioning: {e.response['Error']['Code']}")
        # 5) Logging
        try:
            logging = s3_client.get_bucket_logging(Bucket=bucket_name)
            if 'LoggingEnabled' in logging:
                security_analysis["configuration"]["access_logging"] = True
                security_analysis["recommendations"].append("Access logging is enabled - good for audit trails")
            else:
                security_analysis["configuration"]["access_logging"] = False
                security_analysis["warnings"].append("Access logging is not enabled")
                security_analysis["recommendations"].append("Enable access logging for security monitoring")
        except ClientError as e:
            security_analysis["warnings"].append(f"Could not check logging: {e.response['Error']['Code']}")
        # 6) ACL
        try:
            acl = s3_client.get_bucket_acl(Bucket=bucket_name)
            public_read_grants, public_write_grants = [], []
            for grant in acl.get('Grants', []):
                grantee = grant.get('Grantee', {})
                if grantee.get('URI', '').endswith('AllUsers'):
                    permission = grant.get('Permission')
                    if permission in ['READ', 'FULL_CONTROL']:
                        public_read_grants.append(permission)
                        security_analysis["issues"].append(f"Public {permission} access via ACL"); security_analysis["risk_score"] += 20
                    if permission in ['WRITE', 'FULL_CONTROL']:
                        public_write_grants.append(permission)
                        security_analysis["issues"].append(f"CRITICAL: Public {permission} access via ACL"); security_analysis["risk_score"] += 30
            security_analysis["configuration"]["public_read_acl"] = len(public_read_grants) > 0
            security_analysis["configuration"]["public_write_acl"] = len(public_write_grants) > 0
        except ClientError as e:
            security_analysis["warnings"].append(f"Could not check ACL: {e.response['Error']['Code']}")

        # Heurísticas por nombre
        bucket_lower = bucket_name.lower()
        if any(k in bucket_lower for k in ['log', 'backup', 'archive', 'dump']):
            security_analysis["recommendations"].insert(0, "URGENT: This appears to be a logs/backup bucket - public access should be removed immediately")
            security_analysis["risk_score"] += 15
        if any(k in bucket_lower for k in ['www', 'static', 'public', 'web']):
            security_analysis["recommendations"].append("This appears to be a web hosting bucket - ensure only necessary files are public")
        if any(k in bucket_lower for k in ['temp', 'test', 'dev']):
            security_analysis["recommendations"].append("This appears to be a temporary/development bucket - consider if public access is necessary")

        # Score y salida
        security_analysis["risk_score"] = min(security_analysis["risk_score"], 100)
        if security_analysis["risk_score"] >= 80: risk_level = "CRITICAL"
        elif security_analysis["risk_score"] >= 60: risk_level = "HIGH"
        elif security_analysis["risk_score"] >= 40: risk_level = "MEDIUM"
        elif security_analysis["risk_score"] >= 20: risk_level = "LOW"
        else: risk_level = "MINIMAL"
        security_analysis["risk_level"] = risk_level

        if not security_analysis["recommendations"]:
            security_analysis["recommendations"].append("Review bucket configuration regularly")
        security_analysis["recommendations"].extend([
            "Monitor CloudTrail logs for bucket access patterns",
            "Consider using CloudFront for public content delivery",
            "Implement least privilege access policies",
            "Regular security audits and access reviews"
        ])
        return _ok({"status": "success", "analysis": security_analysis})
    except ClientError as e:
        return _fail(f"AWS error: {e.response['Error']['Code']} - {e.response['Error']['Message']}", 400)
    except Exception as e:
        return _fail(f"Unexpected error during security analysis: {str(e)}", 500)

@app.route('/api/run-secrets-manager-audit', methods=['POST'])
def run_secrets_manager_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        secrets_results = secrets_manager.collect_secrets_manager_data(session)
        return _ok({"metadata": _metadata(session), "results": secrets_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting Secrets Manager data: {str(e)}", 500)

# ==============================================================================
# ----------- BULK JOBS ASÍNCRONOS (ANTI-504) ----------------
# ==============================================================================
EXECUTOR = ThreadPoolExecutor(max_workers=4)  # Puedes tunear con AUDITHOR_WORKERS
JOBS = {}  # job_id -> {"state": "queued|running|done|error", "progress": 0-100, "result": {...}, "error": str, "created_at": ts}

def _new_job():
    job_id = str(uuid.uuid4())
    JOBS[job_id] = {"state": "queued", "progress": 0, "result": None, "error": None, "created_at": time.time()}
    return job_id

def _set_job(job_id, **changes):
    job = JOBS.get(job_id, {})
    job.update(changes)
    JOBS[job_id] = job

def _safe_call(name, fn, *args, **kwargs):
    try:
        return name, fn(*args, **kwargs), None
    except Exception as e:
        return name, None, str(e)

def _run_full_audit(session):
    """Ejecuta todas las colecciones en paralelo por servicio y devuelve shape amigable para tu frontend."""
    meta = _metadata(session)
    tasks = {
        "iam":               lambda: {"results": (lambda r: (r.update({"users": iam.check_critical_permissions(session, r.get("users", []))}) or r))(iam.collect_iam_data(session))},
        "accessAnalyzer":    lambda: {"results": iam.collect_access_analyzer_data(session)},
        "securityhub":       lambda: {"results": (lambda s: {"servicesStatus": [x for x in s if x.get("SecurityHubEnabled")],
                                                              "findings": securityhub.get_and_filter_security_hub_findings(session, s)})(securityhub.check_security_hub_status_in_regions(session, utils.get_all_aws_regions(session)))} ,
        "exposure":          lambda: {"results": (lambda r: (r.update({"lambda_credentials": exposure.scan_lambda_credentials(session)}) or r))(exposure.collect_exposure_data(session))},
        "guardduty":         lambda: {"results": guardduty.collect_guardduty_data(session)},
        "waf":               lambda: {"results": waf.collect_waf_data(session)},
        "cloudtrail":        lambda: {"results": cloudtrail.collect_cloudtrail_data(session)},
        "cloudwatch":        lambda: {"results": cloudwatch.collect_cloudwatch_data(session)},
        "inspector":         lambda: {"results": (lambda s: (s.update({"findings": []}) or s))(inspector.collect_inspector_status(session))},
        "acm":               lambda: {"results": acm.collect_acm_data_web(session)},
        "compute":           lambda: {"results": compute.collect_compute_data(session)},
        "ecr":               lambda: {"results": ecr.collect_ecr_data(session)},
        "databases":         lambda: {"results": databases.collect_database_data(session)},
        "networkPolicies":   lambda: {"results": network_policies.collect_network_policies_data(session)},
        "federation":        lambda: {"results": iam.collect_federation_data(session)},
        "configSHStatus":    lambda: {"results": config_sh.collect_config_sh_status_only(session)},
        "kms":               lambda: {"results": kms.collect_kms_data(session)},
        "secretsManager":    lambda: {"results": secrets_manager.collect_secrets_manager_data(session)},
        "connectivity":      lambda: {"results": connectivity.collect_connectivity_data(session)},
        "codepipeline":      lambda: {"results": codepipeline.collect_codepipeline_data(session)},
        "inventory":         lambda: {"results": inventory.collect_inventory_summary(session)},
        "finops":            lambda: {"results": finops.collect_finops_data(session)},

    }

    total = len(tasks)
    done_count = 0
    partial = {k: None for k in tasks.keys()}

    futures = {EXECUTOR.submit(_safe_call, k, cb): k for k, cb in tasks.items()}
    for fut in as_completed(futures):
        name, data, err = fut.result()
        if err:
            partial[name] = None
        else:
            partial[name] = {"metadata": meta, **data}
        done_count += 1
        progress = int(done_count * 100 / total)
        yield progress, name, err, partial

    final = {
        "iam": partial["iam"],
        "accessAnalyzer": partial["accessAnalyzer"],
        "securityhub": partial["securityhub"],
        "exposure": partial["exposure"],
        "guardduty": partial["guardduty"],
        "waf": partial["waf"],
        "cloudtrail": partial["cloudtrail"],
        "cloudwatch": partial["cloudwatch"],
        "inspector": partial["inspector"],
        "acm": partial["acm"],
        "compute": partial["compute"],
        "ecr": partial["ecr"],
        "databases": partial["databases"],
        "networkPolicies": partial["networkPolicies"],
        "federation": partial["federation"],
        "configSHStatus": partial["configSHStatus"],
        "kms": partial["kms"],
        "secretsManager": partial["secretsManager"],
        "connectivity": partial["connectivity"],
        "codepipeline": partial["codepipeline"],
        "inventory": partial["inventory"],
        "finops": partial["finops"],
    }
    return final

def _job_worker(job_id, payload):
    try:
        session, error = utils.get_session(payload)
        if error:
            _set_job(job_id, state="error", error=error, progress=100)
            return
        _set_job(job_id, state="running", progress=0)

        last_partial = None
        for progress, name, err, partial in _run_full_audit(session):
            _set_job(job_id, progress=progress)
            last_partial = partial

        _set_job(job_id, state="done", progress=100, result=last_partial, error=None)
    except Exception as e:
        _set_job(job_id, state="error", progress=100, error=str(e))

@app.post("/api/run-bulk-audit")
def run_bulk_audit():
    data = request.get_json(silent=True)
    if not data:
        return _fail("Invalid request: expected JSON payload", 400)
    job_id = _new_job()
    threading.Thread(target=_job_worker, args=(job_id, data), daemon=True).start()
    return _ok({"job_id": job_id, "state": "queued"}, 202)

@app.get("/api/scan/status/<job_id>")
def get_scan_status(job_id):
    job = JOBS.get(job_id)
    if not job:
        return _fail("Job not found", 404)
    return _ok({"job_id": job_id, "state": job["state"], "progress": job["progress"], "error": job["error"]})

@app.get("/api/scan/result/<job_id>")
def get_scan_result(job_id):
    job = JOBS.get(job_id)
    if not job:
        return _fail("Job not found", 404)
    if job["state"] != "done":
        return _fail("Job not finished yet", 409, state=job["state"], progress=job["progress"])
    return _ok(job["result"])

@app.get("/health")
def health_root():
    return jsonify(ok=True, path="/health"), 200

@app.get("/api/health")
def health_api():
    return jsonify(ok=True, path="/api/health"), 200


@app.route('/api/run-inventory-audit', methods=['POST'])
def run_inventory_audit():
    session, error = utils.get_session(request.get_json())
    if error: return _fail(error, 401)
    try:
        inventory_results = inventory.collect_inventory_summary(session)
        return _ok({"metadata": _metadata(session), "results": inventory_results})
    except Exception as e:
        return _fail(f"Unexpected error while collecting inventory data: {str(e)}", 500)

# ==============================================================================
# EJECUCIÓN SERVIDOR (solo local; en ECS usarás gunicorn)
# ==============================================================================
if __name__ == '__main__':
    port = 5001
    url = f"http://127.0.0.1:{port}/"
    def open_browser():
        try:
            webbrowser.open_new(url)
        except Exception:
            pass
    threading.Timer(1, open_browser).start()
    app.run(host='0.0.0.0', port=port, debug=False)
